//This library dates back to the yabasic era.
//It is provided here as  a service, but is untested on yab

//Installation: create the directory /boot/home/config/settings/yab and copy or symlink
//the library there.

// **********************************************************************************************************************
// libini.yab                                                                                                           *
// V 1.3                                                                                                                *
//                                                                                                                      *
// 06.01.08 - Added more error checking in various routines.                                                            *
// 02.10.08 - Bug fix. lName$ not declared as local in IniKeyReadName$().                                               *                                                                                                                     *
// 29.12.08 - Added IniKeyCount() and IniSectionCount()                                                                 *
// 21.02.09 - Added Comments.                                                                                           *
//                                                                                                                      *
// See yabasic -docu libini.yab for a list of functions and there parameters.                                           *
// The ini array is divided into "blocks".                                                                              *
// Each block contains the keys and values within one single section with (x, 0, 0) containing the name of the section. *
// (x, 0, 0) is the section name                                                                                        *
// (x, 3, 0) is a list of comment(s) to be inserted into the ini file before the following entries                      *
// (x, 3, 1) is the name of the third key in section x                                                                  *
// (x, 3, 2) is the value of the third key in section x                                                                 *
// libini.yab                                                                                                           *
// Routines for creating, reading and writing ini files.                                                                *
// **********************************************************************************************************************
// Global variables:
gIniMaxSections = 50
gIniMaxKeys = 20
// Limits ini files to 50 sections and 20 keys/values per section.
// Use
// IniSetMaxSections(x)
// and
// IniSetMaxKeys(x)
// to change the values
gIniOnErrorHalt = false
// Stops execution if an error is found.
// Use IniToggleOnErrorHalt() to toggle this value - off by default
gIniLogFile$ = "ini.log"
// By default the current working directory is the home of the log file but using
// IniSetLogFile("path/to/log/file") will set the directory path
//
// *************************************************************
// IniSetMaxSections                                           *
// Params:                                                     *
// lMaxSize: Requested size                                    *
//                                                             *
// Returns:                                                    *
// True if successfully changed else False.                    *
//                                                             *
// Sets the maximum number of allowable sections per ini file. *
// This limit applies to all ini files.                        *
// *************************************************************
//
docu IniSetMaxSections(maximum number of sections)
export sub IniSetMaxSections(lMaxSize)
if lMaxSize < 2 then
	WriteLog("gIniMaxSections is set too low (<2)")
	MyError("gIniMaxSections is set too low (<2)")
	return false
end if
WriteLog("gIniMaxSections = " + str$(lMaxSize))
gIniMaxSections = lMaxSize
return true
end sub
//
// *******************************************************
// IniSetMaxKeys                                         *
// Params:                                               *
// lMaxSize: Requested size                              *
//                                                       *
// Returns:                                              *
// True if successfully changed else False.              *
//                                                       *
// Sets the maximum number of allowable keys per section *
// This limit applies to all sections of all ini files.  *
// *******************************************************
//
docu IniSetMaxKeys(maximum number of keys in section)
export sub IniSetMaxKeys(lMaxSize)
if lMaxSize < 2 then
	WriteLog("gIniMaxKeys is set too low (<2)")
	MyError("gIniMaxKeys is set too low (<2)")
	return false
end if
WriteLog("gIniMaxKeys = " + str$(lMaxSize))
gIniMaxKeys = lMaxSize
return true
end sub
//
// *********************************************************
// IniToggleOnErrorHalt                                    *
//                                                         *
// Params: none                                            *
// Toggles the gIniOnErrorHalt flag between False and True *
//                                                         *
// Returns:                                                *
// True if error reporting is set or                       *
// False if not.                                           *
// *********************************************************
//
docu IniToggleOnErrorHalt()
export sub IniToggleOnErrorHalt()
gIniOnErrorHalt = not gIniOnErrorHalt
if gIniOnErrorHalt = 1 then
	WriteLog("Error reporting on.")
	return true
else
	WriteLog("Error reporting off.")
	return false
end if
end sub
//
// ******************************************
// IniSetLogFile()                          *
// Params:                                  *
// lLogFile$: path and name of the log file *
//                                          *
// Returns:                                 *
// True if successfully changed else False. *
// ******************************************
//
docu IniSetLogFile(/log/file.log) default = current working directory
export sub IniSetLogFile(lLogFile$)
if lLogFile$ = "" then
	MyError("Empty string given as a path and file name for log file! Not changing.")
	return false
end if
gIniLogFile$ = lLogFile$
return true
end sub
//
// *******************************************************************************
// IniLogging:                                                                   *
//                                                                               *
// First call:                                                                   *
// Opens log to record the success/failure of ini file i/o operations.           *
//                                                                               *
// Second call:                                                                  *
// Closes log file                                                               *
// global variables:                                                             *
// gLogStream  = Handle for the log file. If greater than zero log file is open. *
// *******************************************************************************
//
docu IniLogging() Starts/ends logging of i/o operations
export sub IniLogging()
if gLogStream = 0 then
	gLogStream = open(gIniLogFile$, "w")
	WriteLog(gIniLogFile$ + " opened at " + left$(time$, 8))
else
	WriteLog(gIniLogFile$ + " closed at " + left$(time$, 8))
	close #gLogStream
	gLogStream = 0 // Reset handle/flag - file closed
end if
end sub
//
// **********************************************************************
// IniCreate:                                                           *
// Creates/overwrites ini file.                                         *
//                                                                      *
// Params:                                                              *
// lFile$ = Name of Ini file to create/overwrite.                       *
//                                                                      *
// Local Vars:                                                          *
// lStream = Handle for ini file                                        *
// lError$ = Error code for problems arising from creating the ini file *
//                                                                      *
// Returns:                                                             *
// True for successful ini file creation                                *
// False for unsuccessful ini file creation                             *
// **********************************************************************
//
docu IniCreate([path/to/]FileName$) ; Create/overwrite ini file
export sub IniCreate(lFile$)
local lStream
local lError$
WriteLog(lFile$ + " doesn't exist. Creating.")
lStream = open(lFile$, "w")
if lStream = 0 then
	lError$ = peek$("error")
	WriteLog("Can not create " + lFile$ + " - " + lError$)
	MyError("Can not create " + lFile$ + " - " + lError$)
	return false
end if
close #lStream
WriteLog(lFile$ + " created.")
return true
end sub
//
// *************************************************************************************
// IniWrite:                                                                           *
// Write a value to a key within the specified ini file                                *
// Params:                                                                             *
// lIniFile$: IniFile to write.                                                        *
// lSection$: Section name without square brackets - eg. colours rather than [colours] *
// lKey$    : Key name                                                                 *
// lValue   : value of key                                                             *
//                                                                                     *
// Local Vars:                                                                         *
// lSectionPosition: Position of section block in array                                *
// lKeyPosition    : Position of key in section block                                  *
// lIniCreateFlag  : Flag to denote success/failure of ini creation                    *
//                                                                                     *
// Local Array:                                                                        *
// lIni$(): Two dimmed array holding the dumped file                                   *
//                                                                                     *
// Returns                                                                             *
// True for successful write,                                                          *
// False for failure.                                                                  *
//                                                                                     *
// Notes:                                                                              *
// If Ini file, section or key doesn't exist then create it/them.                      *
// *************************************************************************************
//
docu IniWrite(ini file name, section name, key name, value of key)
export sub IniWrite(lIniFile$, lSection$, lKey$, lValue$)
WriteLog("")
WriteLog("sub IniWrite(" + lIniFile$ + ", " + lSection$ + ", " + lKey$ + ", " + lValue$ + ")")
local lIniCreateFlag, lKeyPosition, lSectionPosition
local lIni$(gIniMaxSections, gIniMaxKeys, 2)
if not FileExists(lIniFile$) then
	lIniCreateFlag = IniCreate(lIniFile$)
	if lIniCreateFlag = false then
		WriteLog(lIniFile$ + " not created - exiting.")
		MyError(lIniFile$ + " not created - exiting.")
		return false
	end if
end if
LoadIni(lIniFile$, lIni$())
lSectionPosition = GetSectionPosition(lIni$(), lSection$)
if lSectionPosition = 0 then // unknown section - will create section and add key
	lSectionPosition = CreateSection(lIni$(), lSection$)
end if
lKeyPosition = GetKeyPosition(lIni$(), lSectionPosition, lKey$)
if lKeyPosition = 0 then
	lKeyPosition = CreateKey(lIni$(), lSectionPosition, lKey$)
end if
WriteLog("Writing value \"" + lValue$ + "\" to key " + str$(lKeyPosition) + "(" + lKey$ + ") in section " + str$(lSectionPosition) + "(" + lIni$(lSectionPosition, 0, 0) + ")")
lIni$(lSectionPosition, lKeyPosition, 1) = lKey$
lIni$(lSectionPosition, lKeyPosition, 2) = lValue$
DumpIniArray(lIni$(), lIniFile$)
return true
end sub
//
// ******************************************************************
// IniRead$()                                                       *
//                                                                  *
// Params:                                                          *
// lFile$   : ini file name                                         *
// lSection$: Section name                                          *
// lKey$    : Key name                                              *
// lDummy$  : Value to return if the section or key is not present. *
//                                                                  *
// Local Vars:                                                      *
// lIni$()         : ini array                                      *
// lSectionPosition: Block number of section                        *
// lKeyPosition    : position of key in block                       *
//                                                                  *
// Returns:                                                         *
// The value from the file > section > key if it exists else        *
// returns the dummy value                                          *
// ******************************************************************
//
docu IniRead$(ini file, section name, key name, dummy value)
export sub IniRead$(lFile$, lSection$, lKey$, lDummy$)
WriteLog("")
WriteLog("sub IniRead$(" + lFile$ + ", " + lSection$ + ", " + lKey$ + ", " + lDummy$ + ")")
local lKeyPosition, lSectionPosition
local lIni$(gIniMaxSections, gIniMaxKeys, 2)
if not FileExists(lFile$) then
	WriteLog("Couldn't find file " + lFile$)
	MyError("Couldn't find file " + lFile$)
	return lDummy$
end if
LoadIni(lFile$, lIni$())
lSectionPosition = GetSectionPosition(lIni$(), lSection$)
if lSectionPosition = 0 then
	WriteLog("Section " + lSection$ + " in " + lFile$ + " doesn't exist")
	MyError("Section " + lSection$ + " in " + lFile$ + " doesn't exist")
	return lDummy$
end if
lKeyPosition = GetKeyPosition(lIni$(), lSectionPosition, lKey$)
if lKeyPosition = 0 then
	WriteLog("Key \"" + lKey$ + "\" not found in section block " + str$(lSectionPosition) + "(" + lSection$ + ")")
	MyError("Key \"" + lKey$ + "\" not found in section block " + str$(lSectionPosition) + "(" + lSection$ + ")")
	return lDummy$
end if
WriteLog ("Returning value " + lIni$(lSectionPosition, lKeyPosition, 2))
return lIni$(lSectionPosition, lKeyPosition, 2)
end sub
//
// ************************************************
// IniSectionDelete                               *
// Params:                                        *
// lFile$: ini file                               *
// lSection$: Section marked for deletion         *
//                                                *
// Local vars:                                    *
// lSectionPosition: Block number of this section *
// lIni$()         : Ini array                    *
//                                                *
// Returns:                                       *
// True for success, False for failure            *
// ************************************************
//
docu IniSectionDelete(ini file, section name)
export sub IniSectionDelete(lFile$, lSection$)
WriteLog("")
WriteLog("sub IniSectionDelete(" + lFile$ + ", " + lSection$ + ")")
local lSectionPosition
local lIni$(gIniMaxSections, gIniMaxKeys, 2)
if not FileExists(lFile$) then
	WriteLog("Couldn't find file " + lFile$)
	MyError("Couldn't find file " + lFile$)
	return false
end if
LoadIni(lFile$, lIni$())
lSectionPosition = GetSectionPosition(lIni$(), lSection$)
if lSectionPosition = 0 then
	WriteLog(lSection$ + " doesn't exist in " + lFile$)
	MyError( lSection$ + " doesn't exist in " + lFile$)
	return false
end if
WriteLog("Section \"" + lIni$(lSectionPosition, 0, 0) + "\" deleted from " + lFile$)
lIni$(lSectionPosition, 0, 0) = ""
DumpIniArray(lIni$(), lFile$)
return true
end sub
//
// *****************************************
// IniKeyDelete()                          *
//                                         *
// Params:                                 *
// lFile$   : Ini file                     *
// lSection$: Section name                 *
// lKey$    : Key name                     *
//                                         *
// Local vars:                             *
// lSectionPosition: Section block number  *
// lKeyPosition    : Key position in block *
// lIni$()         : Ini array             *
//                                         *
// Returns:                                *
// True for success, False for failure     *
// *****************************************
//
docu IniKeyDelete(file name, section name, key name)
export sub IniKeyDelete(lFile$, lSection$, lKey$)
WriteLog("")
WriteLog("sub IniKeyDelete(" + lFile$ + ", " + lSection$ + ", " + lKey$ + ")")
local lKeyPosition, lSectionPosition
local lIni$(gIniMaxSections, gIniMaxKeys, 2)
if not FileExists(lFile$) then
	WriteLog("Couldn't find file " + lFile$)
	MyError("Couldn't find file " + lFile$)
	return false
end if
LoadIni(lFile$, lIni$())
lSectionPosition = GetSectionPosition(lIni$(), lSection$)
if lSectionPosition = 0 then
	WriteLog("Section \"" + lSection$ + "\" doesn't exist in " + lFile$)
	MyError("Section \"" + lSection$ + "\" doesn't exist in " + lFile$)
	return false
end if
lKeyPosition = GetKeyPosition(lIni$(), lSectionPosition, lKey$)
if lKeyPosition = 0 then
	WriteLog("Key \"" + lKey$ + "\" doesn't exist in section " + str$(lSectionPosition) + " in file " + lFile$)
	MyError("Key \"" + lKey$ + "\" doesn't exist in section " + str$(lSectionPosition) + " in file " + lFile$)
	return false
end if
WriteLog("Key " + str$(lKeyPosition) + "(" + lKey$ + ") deleted from section " + str$(lSectionPosition) + " (" + lIni$(lSectionPosition, 0, 0) + ")")
lIni$(lSectionPosition, lKeyPosition, 1) = ""
DumpIniArray(lIni$(), lFile$)
return true
end sub
//
// ********************************************
// IniKeyRename                               *
// Params:                                    *
// lFile$      : File name                    *
// lSection$   : Section name                 *
// lOldKeyName$: original name of key         *
// lNewKeyName$: new key name                 *
//                                            *
// Local Vars:                                *
// lIni$()         : ini array                *
// lSectionPosition: block number of position *
// lOldKeyPosition    : position of old key   *
// lNewKeyPosition    : position of new key   *
//                                            *
// Returns:                                   *
// True for success, False for failure        *
// ********************************************
//
docu IniKeyRename(ini file, section, old key name, new key name)
export sub IniKeyRename(lFile$, lSection$, lOldKeyName$, lNewKeyName$)
WriteLog("")
WriteLog("IniKeyRename(" + lFile$ + ", " + lSection$ + ", " + lOldKeyName$ + ", " + lNewKeyName$ + ")")
local lKeyPosition, lSectionPosition
local lIni$(gIniMaxSections, gIniMaxKeys, 2)
if not FileExists(lFile$) then
	WriteLog("Couldn't find file " + lFile$)
	MyError("Couldn't find file " + lFile$)
	return false
end if
LoadIni(lFile$, lIni$())
lSectionPosition = GetSectionPosition(lIni$(), lSection$)
if lSectionPosition = 0 then
	WriteLog(lSection$ + " not found in " + lFile$)
	MyError(lSection$ + " not found in " + lFile$)
	return false
end if
lOldKeyPosition = GetKeyPosition(lIni$(), lSectionPosition, lOldKeyName$)
if lOldKeyPosition = 0 then
	WriteLog(lOldKeyName$ + " in section " + str$(lSectionPosition) + "(" + lSection$ + ") doesn't exist")
	MyError(lOldKeyName$ + " in section " + str$(lSectionPosition) + "(" + lSection$ + ") doesn't exist")
	return false
end if
lNewKeyPosition = GetKeyPosition(lIni$(), lSectionPosition, lNewKeyName$)
if lNewKeyPosition > 0 then
	WriteLog(lNewKeyName$ + " already exists in section block " + str$(lSectionPosition) + "(" + lSection$ + ") so not renaming this key")
	MyError(lNewKeyName$ + " already exists in section block " + str$(lSectionPosition) + "(" + lSection$ + ") so not renaming this key")
	return false
end if
WriteLog("changing " + lOldKeyName$ + " to " + lNewKeyName$)
lIni$(lSectionPosition, lOldKeyPosition, 1) = lNewKeyName$
DumpIniArray(lIni$(), lFile$)
return true
end sub
//
// ************************************************************************
// IniSectionRename                                                       *
// Params:                                                                *
// lFile$: ini file name                                                  *
// lOldSectionName: old section name                                      *
// lNewSectionName: new    "     "                                        *
//                                                                        *
// Local Vars:                                                            *
// lIni$(): ini array                                                     *
// lOldSectionPosition: block number of old section name                  *
// lNewSectionPosition: block number of new section name (error checking) *
// ************************************************************************
//
docu IniSectionRename(ini file name, old section name, new section name)
export sub IniSectionRename(lFile$, lOldSectionName$, lNewSectionName$)
WriteLog("")
WriteLog("IniSectionRename(" + lFile$ + ", " + lOldSectionName$ + ", " + lNewSectionName$)
local lNewSectionPosition, lOldSectionPosition
local lIni$(gIniMaxSections, gIniMaxKeys, 2)
if not FileExists(lFile$) then
	WriteLog("Couldn't find file " + lFile$)
	MyError("Couldn't find file " + lFile$)
	return false
end if
LoadIni(lFile$, lIni$())
lOldSectionPosition = GetSectionPosition(lIni$(), lOldSectionName$)
if lOldSectionPosition = 0 then
	WriteLog(lOldSectionName$ + " not found in " + lFile$)
	MyError(lOldSectionName$ + " not found in " + lFile$)
	return false
end if
lNewSectionPosition = GetSectionPosition(lIni$(), lNewSectionName$)
if lNewSectionPosition > 0 then
	WriteLog(lNewSectionName$ + " already exists in " + lFile$ + " so not renaming this section")
	MyError(lNewSectionName$ + " already exists in " + lFile$ + " so not renaming this section")
	return false
end if
WriteLog("changing " + lOldSectionName$ + " to " + lNewSectionName$)
lIni$(lOldSectionPosition, 0, 0) = "[" + lNewSectionName$ + "]"
DumpIniArray(lIni$(), lFile$)
return true
end sub
//
// *****************************************************************
// IniSectionReadNames                                              *
// Params:                                                         *
// lFile$     : filename                                           *
// lArray$()  : 1 demiensional array                               *
//                                                                 *
// Local Vars                                                      *
// lCount : loop counter                                           *
// lNames$: names of sections delimited with lDelimiter$           *
// Returns:                                                        *
// -1 if the operation failed or the number of section names found *
// *****************************************************************
//
docu IniSectionReadNames(ini file name, 1 dimensional array)
export sub IniSectionReadNames(lFile$, lArray$())
WriteLog("")
WriteLog("IniSectionReadNames(" + lFile$ + ", Array())")
local lCount, lNames, lNum
local lIni$(gIniMaxSections, gIniMaxKeys, 2)
if not FileExists(lFile$) then
	WriteLog("Couldn't find file " + lFile$)
	MyError("Couldn't find file " + lFile$)
	return - 1
end if
LoadIni(lFile$, lIni$())
for lCount = 1 to gIniMaxSections
	lNames$ = lNames$ + lIni$(lCount, 0, 0) + "^"
next lCount
lNum = token(lNames$, lArray$(), "^")
WriteLog("Found " + str$(lNum) + " names")
return lNum
end sub
//
// **********************************************************************
// IniKeyReadNames                                                      *
// Params:                                                              *
// lFile$: ini file name                                                *
// lSection$: Section from which to obtain keys                         *
// lArray$(): 1 dimensional array.                                      *
//    Each element holds both key and value delimited by an equals sign *
//                                                                      *
// Local Vars:                                                          *
// lSectionPosition: Position of section block                          *
// lName$          : temp storage                                       *
// lCount          : loop counter                                       *
// lNum            : token count in lName$                              *
// Returns:                                                             *
// -1 on failure or the number of keys found.                           *
// **********************************************************************
//
docu IniKeyReadNames(ini file name, section to read, 1 dimensional array)
export sub IniKeyReadNames(lFile$, lSection$, lArray$())
WriteLog("")
WriteLog("IniKeyReadNames(" + lFile$ + ", " + lSection$ + ", Array$())")
local lCount, lNum
local lName$
local lIni$(gIniMaxSections, gIniMaxKeys, 2)
if not FileExists(lFile$) then
	WriteLog("Couldn't find file " + lFile$)
	MyError("Couldn't find file " + lFile$)
	return - 1
end if
LoadIni(lFile$, lIni$())
lSectionPosition = GetSectionPosition(lIni$(), lSection$)
if lSectionPosition = 0 then
	WriteLog("Section " + lSection$ + " not found in " + lFile$)
	MyError("Section " + lSection$ + " not found in " + lFile$)
	return - 1
end if
for lCount = 1 to gIniMaxKeys
	if lIni$(lSectionPosition, lCount, 1) <> "" then
		lName$ = lName$ + lIni$(lSectionPosition, lCount, 1) + "=" + lIni$(lSectionPosition, lCount, 2) + "^"
	end if
next lCount
lNum = token(lName$, lArray$(), "^")
WriteLog("Returning " + str$(lNum) + " keys and values")
return lNum
end sub
// ***************************************************************
// IniKeyCount                                                   *
// Params:                                                       *
//    lFile$   : Ini File Name                                   *
//    lSection$: Ini Section Name                                *
//                                                               *
// Locals:                                                       *
//    lResult: The number of keys                                *
// Returns:                                                      *
//    Number of keys in the specified section of the Ini file or *
//    -1 if the file or section doesn't exist                    *
// Notes:                                                        *
//    This is just a wrapper for IniKeyReadNames.                *
// ***************************************************************
doc IniKeyCount(Ini File Name, Section Name)
export sub IniKeyCount(lFile$, lSection$)
WriteLog("")
WriteLog("IniKeyCount(" + lFile$ + ", " + lSection$ + ")")
local lResult
lResult = IniKeyReadNames(lFile$, lSection$)
if lResult > - 1 then
	WriteLog("Returning " + str$(lResult) + " keys found.")
else
	WriteLog("File or section not found.")
end if
return lResult
end sub
// ***************************************************************
// IniSectionCount                                               *
// Params:                                                       *
//    lFile$   : Ini File Name                                   *
//                                                               *
// Locals:                                                       *
//    lResult: The number of sections                            *
// Returns:                                                      *
//    Number of sections in the specified Ini file or            *
//    -1 if the file doesn't exist                               *
// Notes:                                                        *
//    This is just a wrapper for IniSectionReadNames.            *
// ***************************************************************
doc IniSectionCount(Ini File Name, Section Name)
export sub IniSectionCount(lFile$)
WriteLog("")
WriteLog("IniSectionCount(" + lFile$ + ")")
local lResult
lResult = IniSectionReadNames(lFile$)
if lResult > - 1 then
	WriteLog("Returning " + str$(lResult) + " sections found.")
else
	WriteLog("File not found.")
end if
return lResult
end sub

// *******************
//                   *
// Internal Routines *
//                   *
// *******************
//
// ******************************************
// WriteLog:                                *
//                                          *
// Parameter:                               *
// lComment$ = message to be written to log *
// ******************************************
//
sub WriteLog(lComment$)
if gLogStream = 0 then
	return
end if
print #gLogStream, lComment$
end sub
//
// *********************************************
// FileExists:                                 *
//                                             *
//                                             *
// Params:                                     *
// lFile$: Name of file                        *
//                                             *
// local vars:                                 *
// lStream: file handle                        *
// Returns:                                    *
// True if the file is present and             *
// False if not.                               *
//                                             *
// Notes:                                      *
// Checks to see if the specified file exists. *
// *********************************************
//
sub FileExists(lFile$)
local lStream
lStream = open(lFile$, "r")
if lStream > 0 then
	close #lStream
	return true
else
	return false
end if
end sub
//
// *****************************************************************************
// GetSectionPosition()                                                        *
//                                                                             *
// Params:                                                                     *
// lArray$(): Ini file array                                                   *
// lSection$: Search name of section                                           *
// local vars:                                                                 *
// lCount    : read position in array                                          *
// lFound    : if the section is found in lArray$() lFound holds it's position *
//             else 0 if not found                                             *
// *****************************************************************************
//
sub GetSectionPosition(lArray$(), lSection$)
local lCount, lFound
lSection$ = "[" + lSection$ + "]"
for lCount = 1 to gIniMaxSections
	if lArray$(lCount, 0, 0) = "" then
		break // end of sections
	end if
	if lArray$(lCount, 0, 0) = lSection$ then
		lFound = lCount // set flag/marker
		break
	end if
next lCount
if lFound > 0 then
	WriteLog("Position of \"" + lSection$ + "\" found at block " + str$(lFound))
else
	WriteLog("\"" + lSection$ + "\" not found")
end if
return lFound
end sub
//
// ************************************************
// CreateSection()                                *
//                                                *
// Params:                                        *
// lSection$: Name of section                     *
//                                                *
// local vars:                                    *
// lCount: Position of first empty block in array *
//                                                *
// Returns:                                       *
// Block number of section                        *
// ************************************************
//
sub CreateSection(lArray$(), lSection$)
local lCount
WriteLog("Trying to create section \"" + lSection$ + "\"")
for lCount = 1 to gIniMaxSections
	if lArray$(lCount, 0, 0) = "" then
		break
	end if
next lCount
if lCount > gIniMaxSections then // Array full!
	WriteLog("Trying to create " + str$(gIniMaxSections + 1) + " sections - failed. Var libini.gIniMaxSections = " + str$(gIniMaxSections) + ". Use subroutine IniSetMaxSections(x) to adjust this value.")
	gIniOnErrorHalt = true
	MyError("Trying to create " + str$(gIniMaxSections + 1) + " sections - failed. Var libini.gIniMaxSections = " + str$(gIniMaxSections) + ". Use subroutine IniSetMaxSections(x) to adjust this value.")
end if
lArray$(lCount, 0, 0) = "[" + lSection$ + "]"
WriteLog("Section \"" + lArray$(lCount, 0, 0) + "\" created at block " + str$(lCount))
return lCount
end sub
//
// ************************************************************
// GetKeyPosition                                             *
//                                                            *
// Params:                                                    *
// lArray$(): Ini array                                       *
// lSection : Array block to search                           *
// lKey$    : Search item                                     *
//                                                            *
// Local Vars:                                                *
// lCount: position in key area of section block              *
// lFound: Flag indicates if the key was found                *
// Returns the position of the key or zero if it doesn't exist*
// ************************************************************
//
sub GetKeyPosition(lArray$(), lSection, lKey$)
local lCount
for lCount = 1 to gIniMaxKeys
	if lArray$(lSection, lCount, 1) = lKey$ then
		lFound = true
		break
	end if
	if lArray$(lSection, lCount, 1) = "" then // not found
		lFound = false // redundant but who the hell cares?
		break
	end if
next lCount
if not lFound then
	return lFound // Pass back a zero value to indicate failure
else
	WriteLog("Key \"" + lKey$ + "\" found in section " + lArray$(lSection, 0, 0))
	return lCount // return position of Key
end if
end sub
//
// ********************************************************
// CreateKey()                                            *
//                                                        *
// Params:                                                *
// lArray$(): IniArray                                    *
// lSection : position of section                         *
// lKey$    : Name of key                                 *
//                                                        *
// Local Vars:                                            *
// lCount: position of first empty space in section block *
//                                                        *
// Returns position of the key or zero if not found.      *
// ********************************************************
//
sub CreateKey(lArray$(), lSection, lKey$, lValue$)
local lCount
for lCount = 1 to gIniMaxKeys
	if lArray$(lSection, lCount, 1) = "" then // Empty space found
		lArray$(lSection, lCount, 1) = lKey$
		break
	end if
next lCount
if lCount > gIniMaxKeys then
	WriteLog("Tried to create more than " + str$(gIniMaxKeys) + " keys - failed. Var libini.gIniMaxKeys = " + str$(gIniMaxKeys) + ". Use subroutine IniSetMaxKeys(x) to adjust this value.")
	gIniOnErrorHalt = true
	MyError("Tried to create more than " + str$(gIniMaxKeys) + " keys - failed. Var libini.gIniMaxKeys = " + str$(gIniMaxKeys) + ". Use subroutine IniSetMaxKeys(x) to adjust this value.")
end if
WriteLog("Created key \"" + lKey$ + "\" in section " + str$(lSection) + "(" + lArray$(lSection, 0, 0) + ") at location " + str$(lCount))
return lCount
end sub
//
// **********************************************************************
// MyError                                                              *
//                                                                      *
// Params:                                                              *
// lErrorMessage$: self explanatory                                     *
//                                                                      *
// Notes:                                                               *
// Checks gIniOnErrorHalt flag and if set to off returns to the calling *
// routine.                                                             *
// If the flag is set to on an error will be thrown.                    *
// The error will be written to thelog file.                            *
// If the log is open then it will be closed                            *
// **********************************************************************
//
sub MyError(lErrorMessage$)
if gIniOnErrorHalt = false then
	WriteLog("Error found but continuing")
	return
end if
WriteLog("Error found - aborting")
if gLogStream > 0 then
	IniLogging() // close log file
end if
error lErrorMessage$
end sub
//
// ************************************************************
// DumpIniArray                                               *
//                                                            *
// Params:                                                    *
// lArray$(): Ini Array                                       *
// lFile$   : Name of ini file.                               *
//                                                            *
// Local vars:                                                *
// lSection : position of section block                       *
// lKey     : position of key in section                      *
// lStream  : File handle                                     *
// lNum     : Token() counter                                 *
// lI       : Loop Counter                                    *
// lTotal$  : the key/value combination to be dumped to file. *
// lV$()    : Comments                                        *
// ************************************************************
//
sub DumpIniArray(lArray$(), lFile$)
local lKey, lNum, lSection, lStream
local lTotal$
local lV$(1)
lStream = open(lFile$, "w")
for lSection = 1 to gIniMaxSections
	if lArray$(lSection, 0, 0) = "" then // section deleted/end of ini array
		continue
	end if
	print #lStream, lArray$(lSection, 0, 0)
	for lKey = 1 to gIniMaxKeys
		lNum = token(lArray$(lSection, lKey, 0), lV$(), chr$(1))
		for lI = 1 to lNum
			print #lStream, lV$(lI)
		next lI
		if lArray$(lSection, lKey, 1) = "" then // key deleted/end of keys
			continue
		end if
		lTotal$ = lArray$(lSection, lKey, 1) + "=" + lArray$(lSection, lKey, 2)
		print #lStream, lTotal$
	next lKey
next lSection
close #lStream
end sub
//
// *******************************************************************
// LoadIni:                                                          *
// Load the Ini file into array                                      *
//                                                                   *
// Params:                                                           *
// lFile$ : name of file to load ini data                            *
// lArray$: Array to dump file                                       *
//                                                                   *
// Local Vars:                                                       *
// lStream  : File Handle                                            *
// lKeys    : place holder for next key                              *
// lPos     : temp var storing the delimiter between key and value   *
// lSections: Place holder for the current section when being stored *
// lLine$   : Current line from ini file                             *
// *******************************************************************
//
sub LoadIni(lFile$, lArray$())
local lKeys, lPos, lSections, lStream
local lComm$, lLine$
lStream = open(lFile$, "r")
while( ! eof(lStream))
	line input #lStream lLine$
	if left$(lLine$, 1) = "[" then
		lSections = lSections + 1
		if lSections > gIniMaxSections then
			WriteLog("More than " + str$(gIniMaxSections) + " sections in ini file " + lFile$ + ". Var libini.gIniMaxSections = " + str$(gIniMaxSections) + ". Use subroutine IniSetMaxSections(x) to adjust this value.")
			gIniOnErrorHalt = true
			MyError("More than " + str$(gIniMaxSections) + " sections in ini file " + lFile$ + ". Var libini.gIniMaxSections = " + str$(gIniMaxSections) + ". Use subroutine IniSetMaxSections(x) to adjust this value.")
		end if
		lArray$(lSections, 0, 0) = lLine$
		lKeys = 1
	else
		lPos = instr(lLine$, "=")
		if lPos = 0 then
			lComm$ = CommentOrError$(lLine$, lFile$)
			// Program returned so it's a comment
			lArray$(lSections, lKeys, 0) = lArray$(lSections, lKeys, 0) + lComm$ + chr$(1)
		else
			lArray$(lSections, lKeys, 1) = trim$(left$(lLine$, lPos - 1))
			lArray$(lSections, lKeys, 2) = trim$(mid$(lLine$, lPos + 1))
			// Before we go any further remove trailing delimiter from the comments
			right$(lArray$(lSections, lKeys, 0), 1) = " "
			lKeys = lKeys + 1
		end if
		if lKeys > gIniMaxKeys then
			WriteLog("More than " + str$(gIniMaxKeys) + " keys in section " + lArray$(lSections, 0, 0) + " of ini file " + lFile$ + ". Var libini.gIniMaxKeys = " + str$(gIniMaxKeys) + ". Use subroutine IniSetMaxKeys(x) to adjust this value.")
			MyError("More than " + str$(gIniMaxKeys) + " keys in section " + lArray$(lSections, 0, 0) + " of ini file " + lFile$ + ". Var libini.gIniMaxKeys = " + str$(gIniMaxKeys) + ". Use subroutine IniSetMaxKeys(x) to adjust this value.")
		end if
	end if
wend
close #lStream
WriteLog(lFile$ + " read into array")
end sub
//
// *****************************************************************************
// CommentOrError()                                                            *
// Decide if the current line in Ini file is a comment, spacer or mistake      *
//                                                                             *
// Params :                                                                    *
// lLine$ : the line in question                                               *
// lFile$ : Ini file name                                                      *
//                                                                             *
// *****************************************************************************
//
sub CommentOrError$(lLine$, lFIle$)
if trim$(left$(lLine$, 1)) = "#" then
	return lLine$
end if
if trim$(lLine$) = "" then
	return " "
end if
WriteLog("Malformed key \"" + lLine$ + "\" in " + lFile$)
gIniOnErrorHalt = true
MyError("Malformed key \"" + lLine$ + "\" in " + lFile$)
end sub
